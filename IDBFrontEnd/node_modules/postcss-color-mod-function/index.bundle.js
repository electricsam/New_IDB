'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var parser = _interopDefault(require('postcss-values-parser'));
var postcss = _interopDefault(require('postcss'));
var names = _interopDefault(require('color-name'));

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Color = function () {
	function Color(color) {
		_classCallCheck(this, Color);

		this.color = Object(Object(color).color || color);

		if (color.colorspace === 'rgb') {
			this.color.hue = rgb2hue(color.red, color.green, color.blue, color.hue || 0);
		}
	}

	_createClass(Color, [{
		key: 'alpha',
		value: function alpha(_alpha) {
			var color = this.color;

			return _alpha === undefined ? color.alpha : new Color(assign(color, { alpha: _alpha }));
		}
	}, {
		key: 'blackness',
		value: function blackness(_blackness) {
			var hwb = color2hwb(this.color);

			return _blackness === undefined ? hwb.blackness : new Color(assign(hwb, { blackness: _blackness }));
		}
	}, {
		key: 'blend',
		value: function blend(color, percentage) {
			var colorspace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'rgb';

			var base = this.color;

			return new Color(_blend(base, color, percentage, colorspace));
		}
	}, {
		key: 'blenda',
		value: function blenda(color, percentage) {
			var colorspace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'rgb';

			var base = this.color;

			return new Color(_blend(base, color, percentage, colorspace, true));
		}
	}, {
		key: 'blue',
		value: function blue(_blue) {
			var rgb = color2rgb(this.color);

			return _blue === undefined ? rgb.blue : new Color(assign(rgb, { blue: _blue }));
		}
	}, {
		key: 'contrast',
		value: function contrast(percentage) {
			var base = this.color;

			return new Color(_contrast(base, percentage));
		}
	}, {
		key: 'green',
		value: function green(_green) {
			var rgb = color2rgb(this.color);

			return _green === undefined ? rgb.green : new Color(assign(rgb, { green: _green }));
		}
	}, {
		key: 'hue',
		value: function hue(_hue) {
			var hsl = color2hsl(this.color);

			return _hue === undefined ? hsl.hue : new Color(assign(hsl, { hue: _hue }));
		}
	}, {
		key: 'lightness',
		value: function lightness(_lightness) {
			var hsl = color2hsl(this.color);

			return _lightness === undefined ? hsl.lightness : new Color(assign(hsl, { lightness: _lightness }));
		}
	}, {
		key: 'red',
		value: function red(_red) {
			var rgb = color2rgb(this.color);

			return _red === undefined ? rgb.red : new Color(assign(rgb, { red: _red }));
		}
	}, {
		key: 'rgb',
		value: function rgb(red, green, blue) {
			var rgb = color2rgb(this.color);

			return new Color(assign(rgb, { red, green, blue }));
		}
	}, {
		key: 'saturation',
		value: function saturation(_saturation) {
			var hsl = color2hsl(this.color);

			return _saturation === undefined ? hsl.saturation : new Color(assign(hsl, { saturation: _saturation }));
		}
	}, {
		key: 'shade',
		value: function shade(percentage) {
			var hwb = color2hwb(this.color);
			var shade = { hue: 0, whiteness: 1, blackness: 0, colorspace: 'hwb' };
			var colorspace = 'hwb';

			return percentage === undefined ? hwb.blackness : new Color(_blend(hwb, shade, percentage, colorspace));
		}
	}, {
		key: 'tint',
		value: function tint(percentage) {
			var hwb = color2hwb(this.color);
			var tint = { hue: 0, whiteness: 0, blackness: 1, colorspace: 'hwb' };
			var colorspace = 'hwb';

			return percentage === undefined ? hwb.blackness : new Color(_blend(hwb, tint, percentage, colorspace));
		}
	}, {
		key: 'whiteness',
		value: function whiteness(_whiteness) {
			var hwb = color2hwb(this.color);

			return _whiteness === undefined ? hwb.whiteness : new Color(assign(hwb, { whiteness: _whiteness }));
		}
	}, {
		key: 'toHSL',
		value: function toHSL() {
			var color = color2hsl(this.color);
			var isOpaque = color.alpha === 1;
			var hue = color.hue;
			var saturation = round(color.saturation * 100, 4);
			var lightness = round(color.lightness * 100, 4);
			var alpha = round(color.alpha * 100, 4);

			return `hsl(${hue} ${saturation}% ${lightness}%${isOpaque ? '' : ` / ${alpha}%`})`;
		}
	}, {
		key: 'toHWB',
		value: function toHWB() {
			var color = color2hwb(this.color);
			var isOpaque = color.alpha === 1;
			var hue = color.hue;
			var whiteness = round(color.whiteness * 100, 4);
			var blackness = round(color.blackness * 100, 4);
			var alpha = round(color.alpha * 100, 4);

			return `hwb(${hue} ${whiteness}% ${blackness}%${isOpaque ? '' : ` / ${alpha}%`})`;
		}
	}, {
		key: 'toRGB',
		value: function toRGB() {
			var color = color2rgb(this.color);
			var isOpaque = color.alpha === 1;
			var red = round(color.red * 100, 4);
			var green = round(color.green * 100, 4);
			var blue = round(color.blue * 100, 4);
			var alpha = round(color.alpha * 100, 4);

			return `rgb(${red}% ${green}% ${blue}%${isOpaque ? '' : ` / ${alpha}%`})`;
		}
	}, {
		key: 'toRGBLegacy',
		value: function toRGBLegacy() {
			var color = color2rgb(this.color);
			var isOpaque = color.alpha === 1;
			var name = isOpaque ? 'rgb' : 'rgba';
			var red = round(color.red * 255, 0);
			var green = round(color.green * 255, 0);
			var blue = round(color.blue * 255, 0);
			var alpha = round(color.alpha, 4);

			return `${name}(${red}, ${green}, ${blue}${isOpaque ? '' : `, ${alpha}`})`;
		}
	}, {
		key: 'toString',
		value: function toString(rawcolorspace) {
			var colorspace = rawcolorspace || this.color.colorspace;

			var color = colorspace === 'hsl' ? this.toHSL() : colorspace === 'hwb' ? this.toHWB() : this.toRGB();

			return color;
		}
	}]);

	return Color;
}();

function _blend(base, color, percentage, colorspace, isBlendingAlpha) {
	// eslint-disable-line max-params
	var subtraction = 1 - percentage;

	if (colorspace === 'hsl') {
		var _color2hsl = color2hsl(base),
		    h1 = _color2hsl.hue,
		    s1 = _color2hsl.saturation,
		    l1 = _color2hsl.lightness,
		    a1 = _color2hsl.alpha;

		var _color2hsl2 = color2hsl(color),
		    h2 = _color2hsl2.hue,
		    s2 = _color2hsl2.saturation,
		    l2 = _color2hsl2.lightness,
		    a2 = _color2hsl2.alpha;

		var hue = h1 * percentage + h2 * subtraction,
		    saturation = s1 * percentage + s2 * subtraction,
		    lightness = l1 * percentage + l2 * subtraction,
		    alpha = isBlendingAlpha ? a1 * percentage + a2 * subtraction : a1;


		return { hue, saturation, lightness, alpha, colorspace: 'hsl' };
	} else if (colorspace === 'hwb') {
		var _color2hwb = color2hwb(base),
		    _h = _color2hwb.hue,
		    w1 = _color2hwb.whiteness,
		    b1 = _color2hwb.blackness,
		    _a = _color2hwb.alpha;

		var _color2hwb2 = color2hwb(color),
		    _h2 = _color2hwb2.hue,
		    w2 = _color2hwb2.whiteness,
		    b2 = _color2hwb2.blackness,
		    _a2 = _color2hwb2.alpha;

		var _hue2 = _h * percentage + _h2 * subtraction,
		    whiteness = w1 * percentage + w2 * subtraction,
		    blackness = b1 * percentage + b2 * subtraction,
		    _alpha2 = isBlendingAlpha ? _a * percentage + _a2 * subtraction : _a;

		return { hue: _hue2, whiteness, blackness, alpha: _alpha2, colorspace: 'hwb' };
	} else {
		var _color2rgb = color2rgb(base),
		    r1 = _color2rgb.red,
		    g1 = _color2rgb.green,
		    _b = _color2rgb.blue,
		    _a3 = _color2rgb.alpha;

		var _color2rgb2 = color2rgb(color),
		    r2 = _color2rgb2.red,
		    g2 = _color2rgb2.green,
		    _b2 = _color2rgb2.blue,
		    _a4 = _color2rgb2.alpha;

		var red = r1 * percentage + r2 * subtraction,
		    green = g1 * percentage + g2 * subtraction,
		    blue = _b * percentage + _b2 * subtraction,
		    _alpha3 = isBlendingAlpha ? _a3 * percentage + _a4 * subtraction : _a3;

		return { red, green, blue, alpha: _alpha3, colorspace: 'rgb' };
	}
}

/* Assign channels to a new instance of a base color
/* ========================================================================== */

function assign(base, channels) {
	var color = Object.assign({}, base);

	Object.keys(channels).forEach(function (channel) {
		// detect channel
		var isHue = channel === 'hue';
		var isRGB = !isHue && blueGreenRedMatch.test(channel);

		// value of the channel
		var adjustment = channels[channel];

		// value limitations
		var min = 0;
		var max = isHue ? 360 : 1;

		// updated value
		var value = Math.min(Math.max(parseFloat(adjustment), min), max);

		// assign channel to new object
		if (isHue) {
			color.hue = value;
		} else {
			color[channel] = value;

			color.hue = isRGB ? rgb2hue(color.red, color.green, color.blue, base.hue || 0) : base.hue;
		}
	});

	return color;
}

/* Convert colors
/* ========================================================================== */

function color2hsl(color) {
	return color.colorspace === 'rgb' ? rgb2hsl(color, color.hue) : color.colorspace === 'hwb' ? rgb2hsl(hwb2rgb(color), color.hue) : color;
}

function color2hwb(color) {
	return color.colorspace === 'rgb' ? rgb2hwb(color, color.hue) : color.colorspace === 'hsl' ? rgb2hwb(hsl2rgb(color), color.hue) : color;
}

function color2rgb(color) {
	return color.colorspace === 'hsl' ? hsl2rgb(color) : color.colorspace === 'hwb' ? hwb2rgb(color) : color;
}

/* Convert HSL to RGB
/* ========================================================================== */

function hsl2rgb(_ref) {
	var hue = _ref.hue,
	    saturation = _ref.saturation,
	    lightness = _ref.lightness,
	    _ref$alpha = _ref.alpha,
	    alpha = _ref$alpha === undefined ? 1 : _ref$alpha;

	var t2 = lightness <= 0.5 ? lightness * (saturation + 1) : lightness + saturation - lightness * saturation;

	var t1 = lightness * 2 - t2;

	var red = hue2rgb(t1, t2, hue / 60 + 2);
	var green = hue2rgb(t1, t2, hue / 60);
	var blue = hue2rgb(t1, t2, hue / 60 - 2);

	return { hue, red, green, blue, alpha, colorspace: 'rgb' };
}

/* Convert HWB to RGB
/* ========================================================================== */

function hwb2rgb(_ref2) {
	var hue = _ref2.hue,
	    whiteness = _ref2.whiteness,
	    blackness = _ref2.blackness,
	    _ref2$alpha = _ref2.alpha,
	    alpha = _ref2$alpha === undefined ? 1 : _ref2$alpha;

	var ratio = whiteness + blackness;
	var rwhiteness = ratio > 1 ? whiteness / ratio : whiteness;
	var rblackness = ratio > 1 ? blackness / ratio : blackness;

	var value = 1 - rblackness;
	var hexagon = 6 * hue / 360;
	var hexagonFloor = Math.floor(hexagon);
	var hexagonF = hexagonFloor % 6 ? 1 - (hexagon - hexagonFloor) : hexagon - hexagonFloor;
	var interpolation = rwhiteness + hexagonF * (value - rwhiteness);

	var _ref3 = hexagonFloor % 6 === 5 ? [value, rwhiteness, interpolation] : hexagonFloor % 6 === 4 ? [interpolation, rwhiteness, value] : hexagonFloor % 6 === 3 ? [rwhiteness, interpolation, value] : hexagonFloor % 6 === 2 ? [rwhiteness, value, interpolation] : hexagonFloor % 6 === 1 ? [interpolation, value, rwhiteness] : [value, interpolation, rwhiteness],
	    _ref4 = _slicedToArray(_ref3, 3),
	    red = _ref4[0],
	    green = _ref4[1],
	    blue = _ref4[2];

	return { hue, red, green, blue, alpha, colorspace: 'rgb' };
}

/* Convert RGB to HSL
/* ========================================================================== */

function rgb2hsl(_ref5) {
	var red = _ref5.red,
	    green = _ref5.green,
	    blue = _ref5.blue,
	    _ref5$alpha = _ref5.alpha,
	    alpha = _ref5$alpha === undefined ? 1 : _ref5$alpha;
	var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	// eslint-disable-line max-params
	var hue = rgb2hue(red, green, blue, fallback);
	var whiteness = rgb2whiteness(red, green, blue);
	var value = rgb2value(red, green, blue);
	var lightness = wv2lightness(whiteness, value);
	var saturation = lvw2saturation(lightness, value, whiteness);

	return { hue, saturation, lightness, alpha, colorspace: 'hsl' };
}

/* Convert RGB to HWB
/* ========================================================================== */

function rgb2hwb(_ref6) {
	var red = _ref6.red,
	    green = _ref6.green,
	    blue = _ref6.blue,
	    _ref6$alpha = _ref6.alpha,
	    alpha = _ref6$alpha === undefined ? 1 : _ref6$alpha;
	var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	// eslint-disable-line max-params
	var hue = rgb2hue(red, green, blue, fallback);
	var whiteness = rgb2whiteness(red, green, blue);
	var value = rgb2value(red, green, blue);
	var blackness = 1 - value;

	return { hue, whiteness, blackness, alpha, colorspace: 'hwb' };
}

/* Convert Hue to RGB
/* ========================================================================== */

function hue2rgb(t1, t2, hue) {
	var huerange = hue < 0 ? hue + 6 : hue >= 6 ? hue - 6 : hue;

	var rgb = huerange < 1 ? (t2 - t1) * hue + t1 : hue < 3 ? t2 : hue < 4 ? (t2 - t1) * (4 - hue) + t1 : t1;

	return rgb;
}

/* Convert RGB to Hue
/* ========================================================================== */

function rgb2hue(red, green, blue, fallback) {
	// eslint-disable-line max-params
	var whiteness = rgb2whiteness(red, green, blue);
	var value = rgb2value(red, green, blue);
	var chroma = vw2chroma(value, whiteness);

	if (chroma === 0) {
		return fallback;
	} else {
		var segment = value === red ? (green - blue) / chroma : value === green ? (blue - red) / chroma : (red - green) / chroma;

		var shift = value === red ? segment < 0 ? 360 / 60 : 0 / 60 : value === green ? 120 / 60 : 240 / 60;

		var hue = (segment + shift) * 60;

		return hue;
	}
}

/* Contrast functions
/* ========================================================================== */

function _contrast(color, percentage) {
	// https://drafts.csswg.org/css-color/#contrast-adjuster
	var hwb = color2hwb(color);

	// compute the luminance of the color.
	var luminance = rgb2luminance(color.red, color.green, color.blue);

	// the maximum-contrast color, if it is less than .5
	var maxContrastColor = luminance < 0.5
	// hwb(X, 100%, 0%), where X is the hue angle of the color
	? { hue: hwb.hue, whiteness: 100, blackness: 0, alpha: hwb.alpha, colorspace: 'hwb'
		// otherwise, hwb(X, 0%, 100%), where X is the hue angle of the color
	} : { hue: hwb.hue, whiteness: 0, blackness: 1, alpha: hwb.alpha, colorspace: 'hwb' };

	// contrast ratio
	var contrastRatio = colors2contrast(color, maxContrastColor);

	var minContrastColor = contrastRatio > 4.5
	// the color with the smallest contrast ratio with the base color that is greater than 4.5
	? colors2contrastRatioColor(hwb, maxContrastColor)
	// otherwise, the maximum-contrast color
	: maxContrastColor;

	// color(maximum-contrast blend(minimum-contrast <percentage> hwb))
	return _blend(maxContrastColor, minContrastColor, percentage, 'hwb', false);
}

function colors2contrast(color1, color2) {
	// https://drafts.csswg.org/css-color/#contrast-ratio
	var rgb1 = color2rgb(color1);
	var rgb2 = color2rgb(color2);
	var l1 = rgb2luminance(rgb1.red, rgb1.green, rgb1.blue);
	var l2 = rgb2luminance(rgb2.red, rgb2.green, rgb2.blue);

	return l1 > l2
	// if l1 is the relative luminance of the lighter of the colors
	? (l1 + 0.05) / (l2 + 0.05)
	// otherwise, if l2 is the relative luminance of the lighter of the colors
	: (l2 + 0.05) / (l2 + 0.05);
}

function rgb2luminance(red, green, blue) {
	var _ref7 = [channel2luminance(red), channel2luminance(green), channel2luminance(blue)],
	    redLuminance = _ref7[0],
	    greenLuminance = _ref7[1],
	    blueLuminance = _ref7[2];

	// https://drafts.csswg.org/css-color/#luminance

	return 0.2126 * redLuminance + 0.7152 * greenLuminance + 0.0722 * blueLuminance;
}

function channel2luminance(value) {
	// https://drafts.csswg.org/css-color/#luminance
	return value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
}

// return the smallest contrast ratio from a color and a maximum contrast (credit: @thetalecrafter)
function colors2contrastRatioColor(hwb, maxHWB) {
	var modifiedHWB = Object.assign({}, hwb);

	// values to be used for linear interpolations in HWB space
	var minW = hwb.whiteness;
	var minB = hwb.blackness;
	var maxW = maxHWB.whiteness;
	var maxB = maxHWB.blackness;

	// find the color with the smallest contrast ratio with the base color that is greater than 4.5
	while (Math.abs(minW - maxW) > 1 || Math.abs(minB - maxB) > 1) {
		var midW = Math.round((maxW + minW) / 2);
		var midB = Math.round((maxB + minB) / 2);

		modifiedHWB.whiteness = midW;
		modifiedHWB.blackness = midB;

		if (colors2contrast(modifiedHWB, hwb) > 4.5) {
			maxW = midW;
			maxB = midB;
		} else {
			minW = midW;
			minB = midB;
		}
	}

	return modifiedHWB;
}

/* Convert RGB to Whiteness
/* ========================================================================== */

function rgb2whiteness(red, green, blue) {
	return Math.min(red, green, blue);
}

/* Convert RGB to Value
/* ========================================================================== */

function rgb2value(red, green, blue) {
	return Math.max(red, green, blue);
}

/* Convert Whiteness and Value to Lightness
/* ========================================================================== */

function wv2lightness(whiteness, value) {
	return (whiteness + value) / 2;
}

/* Convert Value and Whiteness to Chroma
/* ========================================================================== */

function vw2chroma(value, whiteness) {
	return value - whiteness;
}

/* Convert Lightness, Value, and Whiteness to Saturation
/* ========================================================================== */

function lvw2saturation(lightness, value, whiteness) {
	return whiteness === value ? 0 : lightness < 0.5 ? (value - whiteness) / (value + whiteness) : (value - whiteness) / (2 - value - whiteness);
}

/* Round to decimal place
/* ========================================================================== */

function round(value, decimals) {
	return Number(`${Math.round(`${value}e${decimals}`)}e-${decimals}`);
}

/* Match
/* ========================================================================== */

var blueGreenRedMatch = /^(blue|green|red)$/i;

function manageUnresolved(node, opts, word, message) {
	// eslint-disable-line max-params
	if ('warn' === opts.unresolved) {
		opts.decl.warn(opts.result, message, { word });
	} else if ('ignore' !== opts.unresolved) {
		throw opts.decl.error(message, { word });
	}
}

var _slicedToArray$1 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

// tooling
/* Transform AST
/* ========================================================================== */

function transformAST(node, opts) {
	node.nodes.slice(0).forEach(function (child) {
		if (isColorModFunction(child)) {
			// transform any color-mod() functions
			var color = transformColorModFunction(child, opts);

			if (color) {
				// update the color-mod() function with the transformed value
				child.replaceWith(parser.word({
					value: opts.stringifier(color)
				}));
			}
		} else if (child.nodes && Object(child.nodes).length) {
			transformAST(child, opts);
		}
	});
}

/* Transform <color> functions
/* ========================================================================== */

function transformColor(node, opts) {
	if (isRGBFunction(node)) {
		return transformRGBFunction(node, opts);
	} else if (isHSLFunction(node)) {
		return transformHSLFunction(node, opts);
	} else if (isHWBFunction(node)) {
		return transformHWBFunction(node, opts);
	} else if (isColorModFunction(node)) {
		return transformColorModFunction(node, opts);
	} else if (isHexColor(node)) {
		return transformHexColor(node, opts);
	} else if (isNamedColor(node)) {
		return transformNamedColor(node, opts);
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a color`);
	}
}

// return a transformed rgb/rgba color function
function transformRGBFunction(node, opts) {
	var _transformArgsByParam = transformArgsByParams(node, [
	// [ <percentage>{3} | <rgb-value>{3} ] [ / <alpha-value> ]?
	[transformRGBValue, transformRGBValue, transformRGBValue, isSlash, transformAlpha],
	// <number>#{3} [ , <alpha-value> ]? ]
	[transformRGBValue, isComma, transformRGBValue, isComma, transformRGBValue, isComma, transformAlpha]]),
	    _transformArgsByParam2 = _slicedToArray$1(_transformArgsByParam, 4),
	    red = _transformArgsByParam2[0],
	    green = _transformArgsByParam2[1],
	    blue = _transformArgsByParam2[2],
	    _transformArgsByParam3 = _transformArgsByParam2[3],
	    alpha = _transformArgsByParam3 === undefined ? 1 : _transformArgsByParam3;

	if (red !== undefined) {
		var color = new Color({ red, green, blue, alpha, colorspace: 'rgb' });

		return color;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid rgb() function`);
	}
}

// return a transformed hsl/hsla color function
function transformHSLFunction(node, opts) {
	var _transformArgsByParam4 = transformArgsByParams(node, [
	// <hue> <percentage>{2} [ / <alpha-value> ]?
	[transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha],
	// hue, <percentage>#{2} [ , <alpha-value> ]? ]
	[transformHue, isComma, transformPercentage, isComma, transformPercentage, isComma, transformAlpha]]),
	    _transformArgsByParam5 = _slicedToArray$1(_transformArgsByParam4, 4),
	    hue = _transformArgsByParam5[0],
	    saturation = _transformArgsByParam5[1],
	    lightness = _transformArgsByParam5[2],
	    _transformArgsByParam6 = _transformArgsByParam5[3],
	    alpha = _transformArgsByParam6 === undefined ? 1 : _transformArgsByParam6;

	if (lightness !== undefined) {
		var color = new Color({ hue, saturation, lightness, alpha, colorspace: 'hsl' });

		return color;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid hsl() function`);
	}
}

// return a transformed hwb color function
function transformHWBFunction(node, opts) {
	var _transformArgsByParam7 = transformArgsByParams(node, [
	// <hue> <percentage> <percentage> [ / <alpha-value> ]?
	[transformHue, transformPercentage, transformPercentage, isSlash, transformAlpha]]),
	    _transformArgsByParam8 = _slicedToArray$1(_transformArgsByParam7, 4),
	    hue = _transformArgsByParam8[0],
	    whiteness = _transformArgsByParam8[1],
	    blackness = _transformArgsByParam8[2],
	    _transformArgsByParam9 = _transformArgsByParam8[3],
	    alpha = _transformArgsByParam9 === undefined ? 1 : _transformArgsByParam9;

	if (blackness !== undefined) {
		var color = new Color({ hue, whiteness, blackness, alpha, colorspace: 'hwb' });

		return color;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid hwb() function`);
	}
}

// return a transformed color-mod color function
function transformColorModFunction(node, opts) {
	// [ <color> | <hue> ] <color-adjuster>*
	var _ref = (node.nodes || []).slice(1, -1) || [],
	    _ref2 = _toArray(_ref),
	    colorOrHueNode = _ref2[0],
	    adjusterNodes = _ref2.slice(1);

	if (colorOrHueNode !== undefined) {
		var color = isHue(colorOrHueNode) ? new Color({ hue: transformHue(colorOrHueNode, opts), saturation: 1, lightness: 0.5, alpha: 1, colorspace: 'hsl' }) : transformColor(colorOrHueNode, opts);

		if (color) {
			var adjustedColor = transformColorByAdjusters(color, adjusterNodes, opts);

			return adjustedColor;
		} else {
			return manageUnresolved(node, opts, node.value, `Expected a valid color`);
		}
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid color-mod() function`);
	}
}

// return a transformed hex color
function transformHexColor(node, opts) {
	if (hexColorMatch.test(node.value)) {
		// #<hex-color>{3,4,6,8}
		var _slice = (node.value.match(hexColorMatch) || []).slice(1),
		    _slice2 = _slicedToArray$1(_slice, 8),
		    r = _slice2[0],
		    g = _slice2[1],
		    b = _slice2[2],
		    a = _slice2[3],
		    rr = _slice2[4],
		    gg = _slice2[5],
		    bb = _slice2[6],
		    aa = _slice2[7];

		var color = new Color({
			red: rr !== undefined ? parseInt(rr, 16) / 255 : r !== undefined ? parseInt(r + r, 16) / 255 : 0,
			green: gg !== undefined ? parseInt(gg, 16) / 255 : g !== undefined ? parseInt(g + g, 16) / 255 : 0,
			blue: bb !== undefined ? parseInt(bb, 16) / 255 : b !== undefined ? parseInt(b + b, 16) / 255 : 0,
			alpha: aa !== undefined ? parseInt(aa, 16) / 255 : a !== undefined ? parseInt(a + a, 16) / 255 : 1
		});

		return color;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid hex color`);
	}
}

// return a transformed named-color
function transformNamedColor(node, opts) {
	if (isNamedColor(node)) {
		// <named-color>
		var _names$node$value = _slicedToArray$1(names[node.value], 3),
		    red = _names$node$value[0],
		    green = _names$node$value[1],
		    blue = _names$node$value[2];

		var color = new Color({ red: red / 255, green: green / 255, blue: blue / 255, alpha: 1, colorspace: 'rgb' });

		return color;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid named-color`);
	}
}

/* Transform <color-adjuster> functions
/* ========================================================================== */

// return a transformed color using adjustments
function transformColorByAdjusters(color, adjusterNodes, opts) {
	var adjustedColor = adjusterNodes.reduce(function (base, node) {
		if (isAlphaBlueGreenRedAdjuster(node)) {
			return transformAlphaBlueGreenRedAdjuster(base, node, opts);
		} else if (isRGBAdjuster(node)) {
			return transformRGBAdjuster(base, node, opts);
		} else if (isHueAdjuster(node)) {
			return transformHueAdjuster(base, node, opts);
		} else if (isBlacknessLightnessSaturationWhitenessAdjuster(node)) {
			return transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts);
		} else if (isShadeTintAdjuster(node)) {
			return transformShadeTintAdjuster(base, node, opts);
		} else if (isBlendAdjuster(node)) {
			return transformBlendAdjuster(base, node, node.value === 'blenda', opts);
		} else if (isContrastAdjuster(node)) {
			return transformContrastAdjuster(base, node, opts);
		} else {
			manageUnresolved(node, opts, node.value, `Expected a valid color adjuster`);

			return base;
		}
	}, color);

	return adjustedColor;
}

// return a transformed color using a/alpha/blue/green/red adjustments
function transformAlphaBlueGreenRedAdjuster(base, node, opts) {
	var _transformArgsByParam10 = transformArgsByParams(node, alphaMatch.test(node.value) ? [
	// [ + | - ] <alpha-value>
	[transformMinusPlusOperator, transformAlpha],
	// * <alpha-value>
	[transformTimesOperator, transformPercentage],
	// <alpha-value>
	[transformAlpha]] : [
	// [ + | - ] <rgb-value>
	[transformMinusPlusOperator, transformRGBValue],
	// * <percentage>
	[transformTimesOperator, transformPercentage],
	// <rgb-value>
	[transformRGBValue]]),
	    _transformArgsByParam11 = _slicedToArray$1(_transformArgsByParam10, 2),
	    operatorOrValue = _transformArgsByParam11[0],
	    adjustment = _transformArgsByParam11[1];

	if (operatorOrValue !== undefined) {
		// normalized channel name
		var channel = node.value.toLowerCase().replace(alphaMatch, 'alpha');

		var existingValue = base[channel]();

		var modifiedValue = adjustment ? operatorOrValue === '+' ? existingValue + adjustment : operatorOrValue === '-' ? existingValue - adjustment : operatorOrValue === '*' ? existingValue * adjustment : adjustment : operatorOrValue;

		var modifiedColor = base[channel](modifiedValue);

		return modifiedColor;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid modifier()`);
	}
}

// return a transformed color using an rgb adjustment
function transformRGBAdjuster(base, node, opts) {
	var _transformArgsByParam12 = transformArgsByParams(node, [
	// [ + | - ] <number> <number> <number>
	[transformMinusPlusOperator, transformRGBNumber, transformRGBNumber, transformRGBNumber],
	// [ + | - ] <percentage> <percentage> <percentage>
	[transformMinusPlusOperator, transformPercentage, transformPercentage, transformPercentage],
	// [ + | - ] <hash-token>
	[transformMinusPlusOperator, transformHexColor],
	// [ * ] <percentage>
	[transformTimesOperator, transformPercentage]]),
	    _transformArgsByParam13 = _slicedToArray$1(_transformArgsByParam12, 4),
	    arg1 = _transformArgsByParam13[0],
	    arg2 = _transformArgsByParam13[1],
	    arg3 = _transformArgsByParam13[2],
	    arg4 = _transformArgsByParam13[3];

	if (arg2 !== undefined && arg2.color) {
		var modifiedColor = base.rgb(arg1 === '+' ? base.red() + arg2.red() : base.red() - arg2.red(), arg1 === '+' ? base.green() + arg2.green() : base.green() - arg2.green(), arg1 === '+' ? base.blue() + arg2.blue() : base.blue() - arg2.blue());

		return modifiedColor;
	} else if (arg1 !== undefined && minusPlusMatch.test(arg1)) {
		var _modifiedColor = base.rgb(arg1 === '+' ? base.red() + arg2 : base.red() - arg2, arg1 === '+' ? base.green() + arg3 : base.green() - arg3, arg1 === '+' ? base.blue() + arg4 : base.blue() - arg4);

		return _modifiedColor;
	} else if (arg1 !== undefined && arg2 !== undefined) {
		var _modifiedColor2 = base.rgb(base.red() * arg2, base.green() * arg2, base.blue() * arg2);

		return _modifiedColor2;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid rgb() adjuster)`);
	}
}

// return a transformed color using a blend/blenda adjustment
function transformBlendAdjuster(base, node, isAlphaBlend, opts) {
	// eslint-disable-line max-params
	var _transformArgsByParam14 = transformArgsByParams(node, [[transformColor, transformPercentage, transformColorSpace]]),
	    _transformArgsByParam15 = _slicedToArray$1(_transformArgsByParam14, 3),
	    color = _transformArgsByParam15[0],
	    percentage = _transformArgsByParam15[1],
	    _transformArgsByParam16 = _transformArgsByParam15[2],
	    colorspace = _transformArgsByParam16 === undefined ? 'rgb' : _transformArgsByParam16;

	if (percentage !== undefined) {
		var modifiedColor = isAlphaBlend ? base.blenda(color.color, percentage, colorspace) : base.blend(color.color, percentage, colorspace);

		return modifiedColor;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid blend() adjuster)`);
	}
}

// return a transformed color using a contrast adjustment
function transformContrastAdjuster(base, node, opts) {
	var _transformArgsByParam17 = transformArgsByParams(node, [
	// <percentage>
	[transformPercentage]]),
	    _transformArgsByParam18 = _slicedToArray$1(_transformArgsByParam17, 1),
	    percentage = _transformArgsByParam18[0];

	if (percentage !== undefined) {
		var modifiedColor = base.contrast(percentage);

		return modifiedColor;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid contrast() adjuster)`);
	}
}

// return a transformed color using a hue adjustment
function transformHueAdjuster(base, node, opts) {
	var _transformArgsByParam19 = transformArgsByParams(node, [
	// [ + | - | * ] <angle>
	[transformMinusPlusTimesOperator, transformHue],
	// <angle>
	[transformHue]]),
	    _transformArgsByParam20 = _slicedToArray$1(_transformArgsByParam19, 2),
	    operatorOrHue = _transformArgsByParam20[0],
	    rawAdjustment = _transformArgsByParam20[1];

	if (operatorOrHue !== undefined) {
		var existingHue = base.hue();
		var adjustment = parseFloat(rawAdjustment);

		var rawModifiedValue = adjustment ? operatorOrHue === '+' ? existingHue + adjustment : operatorOrHue === '-' ? existingHue - adjustment : operatorOrHue === '*' ? existingHue * adjustment : adjustment : parseFloat(operatorOrHue);

		var modifiedValue = rawModifiedValue < 0 ? 360 + rawModifiedValue % 360 : rawModifiedValue % 360;

		return base.hue(modifiedValue);
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid hue() function)`);
	}
}

// [ b | blackness | l | lightness | s | saturation | w | whiteness ]( [ + | - | * ]? <percentage> )
function transformBlacknessLightnessSaturationWhitenessAdjuster(base, node, opts) {
	var channel = node.value.toLowerCase().replace(/^b$/, 'blackness').replace(/^l$/, 'lightness').replace(/^s$/, 'saturation').replace(/^w$/, 'whiteness');

	var _transformArgsByParam21 = transformArgsByParams(node, [[transformMinusPlusTimesOperator, transformPercentage], [transformPercentage]]),
	    _transformArgsByParam22 = _slicedToArray$1(_transformArgsByParam21, 2),
	    operatorOrValue = _transformArgsByParam22[0],
	    rawAdjustment = _transformArgsByParam22[1];

	if (operatorOrValue !== undefined) {
		var existingValue = base[channel]();
		var adjustment = parseFloat(rawAdjustment);

		var modifiedValue = adjustment ? operatorOrValue === '+' ? existingValue + adjustment : operatorOrValue === '-' ? existingValue - adjustment : operatorOrValue === '*' ? existingValue * adjustment : adjustment : parseFloat(operatorOrValue);

		return base[channel](modifiedValue);
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid ${channel}() function)`);
	}
}

// return a transformed color using shade/tint adjustments
function transformShadeTintAdjuster(base, node, opts) {
	var channel = node.value.toLowerCase();

	var _transformArgsByParam23 = transformArgsByParams(node, [
	// [ shade | tint ]( <percentage> )
	[transformPercentage]]),
	    _transformArgsByParam24 = _slicedToArray$1(_transformArgsByParam23, 1),
	    percentage = _transformArgsByParam24[0];

	if (percentage !== undefined) {
		var modifiedValue = parseFloat(percentage);

		return base[channel](modifiedValue);
	} else {
		return manageUnresolved(node, opts, node.value, `Expected valid ${channel}() arguments`);
	}
}

/* Argument Transforms
/* ========================================================================== */

// return a transformed color space
function transformColorSpace(node, opts) {
	if (isColorSpace(node)) {
		// [ hsl | hwb | rgb ]
		return node.value;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid color space)`);
	}
}

// return a transformed alpha value
function transformAlpha(node, opts) {
	if (isNumber(node)) {
		// <number>
		return parseFloat(node.value);
	} else if (isPercentage(node)) {
		// <percentage>
		return transformPercentage(node, opts);
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid alpha value)`);
	}
}

// return a transformed rgb value
function transformRGBValue(node, opts) {
	if (isNumber(node)) {
		// <rgba-number>
		return transformRGBNumber(node, opts);
	} else if (isPercentage(node)) {
		// <percentage>
		return transformPercentage(node, opts);
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid RGB value)`);
	}
}

// return a transformed rgb number
function transformRGBNumber(node, opts) {
	if (isNumber(node)) {
		// <rgba-number>
		return parseFloat(node.value) / 255;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid RGB value)`);
	}
}

// return a transformed hue
function transformHue(node, opts) {
	if (isHue(node)) {
		// <hue>
		return parseFloat(node.value);
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid hue`);
	}
}

// return a transformed percentage
function transformPercentage(node, opts) {
	if (isPercentage(node)) {
		// <percentage>
		return parseFloat(node.value) / 100;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a valid hue`);
	}
}

// return a transformed minus-plus operator
function transformMinusPlusOperator(node, opts) {
	if (isMinusPlusOperator(node)) {
		// [ - | + ]
		return node.value;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a plus or minus operator`);
	}
}

// return a transformed times operator
function transformTimesOperator(node, opts) {
	if (isTimesOperator(node)) {
		// [ * ]
		return node.value;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a times operator`);
	}
}

// return a transformed minus-plus-times operator
function transformMinusPlusTimesOperator(node, opts) {
	if (isMinusPlusTimesOperator(node)) {
		// [ - | + | * ]
		return node.value;
	} else {
		return manageUnresolved(node, opts, node.value, `Expected a plus, minus, or times operator`);
	}
}

/* Transform helper
/* ========================================================================== */

// return the first set of transformed arguments allowable by the parameters
function transformArgsByParams(node, params) {
	var nodes = (node.nodes || []).slice(1, -1);
	var opts = { unresolved: 'ignore' };

	return params.map(function (param) {
		return nodes.map(function (childNode, index) {
			return typeof param[index] === 'function' ? param[index](childNode, opts) : undefined;
		}).filter(function (child) {
			return typeof child !== 'boolean';
		});
	}).filter(function (param) {
		return param.every(function (result) {
			return result !== undefined;
		});
	})[0] || [];
}

/* Adjustment validators
/* ========================================================================== */

// return whether the node is an a/alpha/blue/green/red adjuster
function isAlphaBlueGreenRedAdjuster(node) {
	// [ a(), alpha(), blue(), green(), red() ]
	return Object(node).type === 'func' && alphaBlueGreenRedMatch.test(node.value);
}

// return whether the node is an rgb adjuster
function isRGBAdjuster(node) {
	return Object(node).type === 'func' && rgbMatch.test(node.value);
}

// return whether the node is a hue adjuster
function isHueAdjuster(node) {
	// [ h() | hue() ]
	return Object(node).type === 'func' && hueMatch.test(node.value);
}

// return whether the node is a blackness/lightness/saturation/whiteness adjuster
function isBlacknessLightnessSaturationWhitenessAdjuster(node) {
	// [ b() | blackness() | l() | lightness() | s() | saturation() | w() | whiteness() ]
	return Object(node).type === 'func' && blacknessLightnessSaturationWhitenessMatch.test(node.value);
}

// return whether the node is a shade/tint adjuster
function isShadeTintAdjuster(node) {
	// [ shade() | tint() ]
	return Object(node).type === 'func' && shadeTintMatch.test(node.value);
}

// return whether the node is a blend adjuster
function isBlendAdjuster(node) {
	// [ blend(), blenda() ]
	return Object(node).type === 'func' && blendMatch.test(node.value);
}

// return whether the node is a contrast adjuster
function isContrastAdjuster(node) {
	// [ contrast() ]
	return Object(node).type === 'func' && contrastMatch.test(node.value);
}

/* Color validators
/* ========================================================================== */

// return whether the node is an rgb/rgba color function
function isRGBFunction(node) {
	// [ rgb(), rgba() ]
	return Object(node).type === 'func' && rgbaMatch.test(node.value);
}

// return whether the node is an hsl color function
function isHSLFunction(node) {
	// [ hsl(), hsla() ]
	return Object(node).type === 'func' && hslaMatch.test(node.value);
}

// return whether the node is an hwb color function
function isHWBFunction(node) {
	// hwb()
	return Object(node).type === 'func' && hwbMatch.test(node.value);
}

// return whether the node is a color-mod function
function isColorModFunction(node) {
	// color-mod()
	return Object(node).type === 'func' && colorModMatch.test(node.value);
}

// return whether the node is a valid named-color
function isNamedColor(node) {
	return Object(node).type === 'word' && node.value in names;
}

// return whether the node is a valid hex color
function isHexColor(node) {
	// #<hex-color>{3,4,6,8}
	return Object(node).type === 'word' && hexColorMatch.test(node.value);
}

// return whether the node is a valid color space
function isColorSpace(node) {
	// [ hsl | hwb | rgb ]
	return Object(node).type === 'word' && colorSpaceMatch.test(node.value);
}

/* Additional validators
/* ========================================================================== */

// return whether the hue value is valid
function isHue(node) {
	return Object(node).type === 'number' && /^(deg)?$/.test(node.unit);
}

// return whether the comma is valid
function isComma(node) {
	return Object(node).type === 'comma';
}

// return whether the slash operator is valid
function isSlash(node) {
	return Object(node).type === 'operator' && node.value === '/';
}

// return whether the number is valid
function isNumber(node) {
	return Object(node).type === 'number' && node.unit === '';
}

// return whether the mind-plus operator is valid
function isMinusPlusOperator(node) {
	return Object(node).type === 'operator' && minusPlusMatch.test(node.value);
}

// return whether the minus-plus-times operator is valid
function isMinusPlusTimesOperator(node) {
	return Object(node).type === 'operator' && minusPlusTimesMatch.test(node.value);
}

// return whether the times operator is valid
function isTimesOperator(node) {
	return Object(node).type === 'operator' && timesMatch.test(node.value);
}

// return whether the percentage is valid
function isPercentage(node) {
	return Object(node).type === 'number' && node.unit === '%';
}

/* Matchers
/* ========================================================================== */

var alphaMatch = /^a(lpha)?$/i;
var alphaBlueGreenRedMatch = /^(a(lpha)?|blue|green|red)$/i;
var blacknessLightnessSaturationWhitenessMatch = /^(b(lackness)?|l(ightness)?|s(aturation)?|w(hiteness)?)$/i;
var blendMatch = /^blenda?$/i;
var colorModMatch = /^color-mod$/i;
var colorSpaceMatch = /^(hsl|hwb|rgb)$/i;
var contrastMatch = /^contrast$/i;
var hexColorMatch = /^#(?:([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?|([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?)$/i;
var hslaMatch = /^hsla?$/i;
var hueMatch = /^h(ue)?$/i;
var hwbMatch = /^hwb$/i;
var minusPlusMatch = /^[+-]$/;
var minusPlusTimesMatch = /^[*+-]$/;
var rgbMatch = /^rgb$/i;
var rgbaMatch = /^rgba?$/i;
var shadeTintMatch = /^(shade|tint)$/i;
var timesMatch = /^[*]$/;

// tooling
// plugin
var index = postcss.plugin('postcss-color-mod-function', function (opts) {
	var unresolvedOpt = String(Object(opts).unresolved || 'throw').toLowerCase();
	var stringifierOpt = Object(opts).stringifier || function (color) {
		return color.toRGBLegacy();
	};

	return function (root, result) {
		root.walkDecls(function (decl) {
			var originalValue = decl.value;

			if (colorModFunctionMatch.test(originalValue)) {
				var ast = parser(originalValue, { loose: true }).parse();

				transformAST(ast, { unresolved: unresolvedOpt, stringifier: stringifierOpt, decl, result });

				var modifiedValue = ast.toString();

				if (originalValue !== modifiedValue) {
					decl.value = modifiedValue;
				}
			}
		});
	};
});

var colorModFunctionMatch = /(^|\s)color-mod\(/i;

module.exports = index;
